---
interface Stat {
  value: number;
  label: string;
  suffix?: string;
  prefix?: string;
}

interface Props {
  stats: Stat[];
}

const { stats } = Astro.props;
---

<div class="stats-container">
  {stats.map((stat) => (
    <div class="stat-item">
      <div
        class="stat-number"
        data-target={stat.value}
        data-prefix={stat.prefix || ''}
        data-suffix={stat.suffix || ''}
      >
        {stat.prefix || ''}<span class="counter">0</span>{stat.suffix || ''}
      </div>
      <div class="stat-label">{stat.label}</div>
    </div>
  ))}
</div>

<script>
  function animateCounter(element: HTMLElement) {
    const target = parseInt(element.dataset.target || '0');
    const prefix = element.dataset.prefix || '';
    const suffix = element.dataset.suffix || '';
    const counter = element.querySelector('.counter');

    if (!counter) return;

    const duration = 2000; // 2 segundos
    const steps = 60;
    const increment = target / steps;
    let current = 0;

    const timer = setInterval(() => {
      current += increment;
      if (current >= target) {
        counter.textContent = target.toString();
        clearInterval(timer);
      } else {
        counter.textContent = Math.floor(current).toString();
      }
    }, duration / steps);
  }

  // Intersection Observer para activar cuando sea visible
  const observer = new IntersectionObserver(
    (entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          const statNumbers = entry.target.querySelectorAll('.stat-number');
          statNumbers.forEach((stat) => {
            animateCounter(stat as HTMLElement);
          });
          observer.unobserve(entry.target);
        }
      });
    },
    { threshold: 0.5 }
  );

  const statsContainer = document.querySelector('.stats-container');
  if (statsContainer) {
    observer.observe(statsContainer);
  }
</script>

<style>
  .stats-container {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 3rem;
    margin: 3rem 0;
    padding: 2rem 0;
  }

  .stat-item {
    text-align: center;
    position: relative;
  }

  /* LÃ­nea vertical blanca delgada entre items */
  .stat-item:not(:last-child)::after {
    content: '';
    position: absolute;
    right: -1.5rem;
    top: 50%;
    transform: translateY(-50%);
    height: 80%;
    width: 1px;
    background: linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0) 0%,
      rgba(255, 255, 255, 0.5) 50%,
      rgba(255, 255, 255, 0) 100%
    );
  }

  .stat-number {
    font-size: clamp(2.5rem, 5vw, 4rem);
    font-weight: 800;
    background: linear-gradient(
      90deg,
      rgba(255, 255, 255, 0.8) 0%,
      rgba(255, 255, 255, 1) 50%,
      rgba(255, 255, 255, 0.8) 100%
    );
    background-size: 200% 100%;
    background-clip: text;
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    animation: shimmer 3s ease-in-out infinite;
    margin-bottom: 0.5rem;
  }

  @keyframes shimmer {
    0%, 100% {
      background-position: 0% 0%;
    }
    50% {
      background-position: 100% 0%;
    }
  }

  .stat-label {
    font-size: clamp(0.9rem, 1.5vw, 1.1rem);
    color: rgba(255, 255, 255, 0.7);
    text-transform: uppercase;
    letter-spacing: 0.1em;
    font-weight: 500;
  }

  @media (max-width: 768px) {
    .stats-container {
      gap: 2rem;
      margin: 2rem 0;
    }

    .stat-item:not(:last-child)::after {
      display: none;
    }
  }
</style>
